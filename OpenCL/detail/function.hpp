#if !defined(OPENCL_MAX_FUNCTION_ARGS)
    #define OPENCL_MAX_FUNCTION_ARGS 6
#endif

#if !defined(OPENCL_DONT_USE_PREPROCESSED_FILES)
    #include "./preprocessed/function.hpp"
#else
#if !BOOST_PP_IS_ITERATING
#include <boost/preprocessor/iteration/iterate.hpp>
#include <boost/preprocessor/enum.hpp>
#include <boost/preprocessor/enum_params.hpp>
#include <boost/preprocessor/repetition/enum_binary_params.hpp>

#if defined(__WAVE__) && defined(OPENCL_CREATE_PREPROCESSED_FILES)
    #pragma wave option(preserve: 2, line: 0, output: "./preprocessed/function.hpp")
#endif
//
//  Copyright Brandon Kohn 2012
//
//  Distributed under the Boost Software License, Version 1.0. (See
//  accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)
//! THIS FILE IS AUTOGENERATED. CHANGES MADE TO THIS FILE WILL BE 
//! LOST WHEN IT IS REGENERATED.
//
#if defined(__WAVE__) && defined(OPENCL_CREATE_PREPROCESSED_FILES)
#pragma wave option(preserve: 2)
#endif
namespace opencl
{
    template <typename Signature, int Arity = 0>
    struct function_impl
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim)                 
            , eventwaitlist(eventWaitList)
        {
            globalthreads.assign(globalThreads, globalThreads + workDim);
            localthreads.assign(localThreads, localThreads + workDim);
            if( workDimOffsets != 0 )
                offsets.assign(workDimOffsets, workDimOffsets+workDim);            
        }
                
        template <typename S>
        struct result;

        template<typename RT>                                                                        
        struct result<RT()>               
        {                                                                        
            typedef RT type;                                                     
        };                                                                       

        void operator()() 
        { 
            cl_int status; 
            cl_event ndrEvt; 
            cl_int eventStatus = CL_QUEUED; 

            status = clEnqueueNDRangeKernel( 
                cmdQ, 
                knl, 
                workdims, 
                offsets.empty() ? 0 : &offsets[0], 
                &globalthreads[0], 
                &localthreads[0], 
                eventwaitlist.size(), 
                eventwaitlist.empty() ? 0 : &eventwaitlist[0], 
                &ndrEvt); 
            assert(status == CL_SUCCESS); 
            status = clFlush(cmdQ); 
            assert(status == CL_SUCCESS); 
            eventStatus = CL_QUEUED; 
            while(eventStatus != CL_COMPLETE) 
            { 
                status = clGetEventInfo( 
                    ndrEvt, 
                    CL_EVENT_COMMAND_EXECUTION_STATUS, 
                    sizeof(cl_int), 
                    &eventStatus, 
                    0); 
                assert(status == CL_SUCCESS); 
            } 
            status = clReleaseEvent(ndrEvt); 
            assert(status == CL_SUCCESS); 
        } 

    private:
        kernel        knl;
        cl_context    ctx;
        command_queue cmdQ;
        std::size_t   workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event>    eventwaitlist;
    };

    #define BOOST_PP_ITERATION_PARAMS_1 (3, (1, OPENCL_MAX_FUNCTION_ARGS, "./function.hpp"))
    #include BOOST_PP_ITERATE()   

	template <typename Signature>
	class function : function_impl<Signature, boost::function_types::function_arity<Signature>::value>
	{
        typedef function_impl<Signature, boost::function_types::function_arity<Signature>::value> base_type;
	public:

		function( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
                , const std::size_t* globalThreads, const std::size_t* localThreads
                , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
			: base_type(knl, ctx, q, workDim, globalThreads, localThreads, eventWaitList, workDimOffsets)
		{}
	
        using base_type::operator();
   };
}//namespace opencl;

#else
    #define N BOOST_PP_FRAME_ITERATION(1)
    #define OPENCL_MAKE_ARG(z, n, data)              \
        arg<T ## n> arg ## n(n,a ## n,ctx,cmdQ,knl); \
    /***/
    #define OPENCL_MAKE_ARGS(n)                \
	    BOOST_PP_REPEAT(n, OPENCL_MAKE_ARG, _) \
    /***/
    #define OPENCL_READ_DATA(z, n, data)       \
        arg ## n.read_data();                  \

    template <typename Signature>
    struct function_impl<Signature,N>
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim)                 
            , eventwaitlist(eventWaitList)
        {
            globalthreads.assign(globalThreads, globalThreads + workDim);
            localthreads.assign(localThreads, localThreads + workDim);
            if( workDimOffsets != 0 )
                offsets.assign(workDimOffsets, workDimOffsets+workDim);            
        }

        template <typename S>
        struct result;

        template< typename RT BOOST_PP_COMMA_IF(N) BOOST_PP_ENUM_PARAMS(N, typename T) >                                                                        
        struct result<RT(BOOST_PP_ENUM_PARAMS(N,T)) >
        {                                                                        
            typedef RT type;                                                     
        };                                                                       

        template<BOOST_PP_ENUM_PARAMS(N, typename T) >
        void operator()(BOOST_PP_ENUM_BINARY_PARAMS(N, T, &a))                
        {                                                                        
            cl_int   status;                                                     
            cl_event ndrEvt;                                                     
            cl_int eventStatus = CL_QUEUED;                                      
            OPENCL_MAKE_ARGS(N)                                                  
            status = clFlush(cmdQ);                                              
            assert( status == CL_SUCCESS );                                      
            status = clEnqueueNDRangeKernel(
                cmdQ,
                knl,
                workdims,
                offsets.empty() ? 0 : &offsets[0],
                &globalthreads[0],
                &localthreads[0],
                eventwaitlist.size(),
                eventwaitlist.empty() ? 0 : &eventwaitlist[0],
                &ndrEvt);
            assert(status == CL_SUCCESS);
            status = clFlush(cmdQ);
            assert(status == CL_SUCCESS);
            eventStatus = CL_QUEUED;
            while(eventStatus != CL_COMPLETE)                                    
            {                                                                    
                status = clGetEventInfo(                                         
                    ndrEvt,                                                      
                    CL_EVENT_COMMAND_EXECUTION_STATUS,                           
                    sizeof(cl_int),                                              
                    &eventStatus,                                                
                    0);                                                          
                assert(status == CL_SUCCESS);                                    
            }                                                                    
            status = clReleaseEvent(ndrEvt);                                     
            assert(status == CL_SUCCESS);    

            BOOST_PP_REPEAT(N, OPENCL_READ_DATA,_)
            status = clFlush(cmdQ);            
        }

    private:
        kernel        knl;
        cl_context    ctx;
        command_queue cmdQ;
        std::size_t   workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event>    eventwaitlist;
    };

    #undef N
    #undef OPENCL_MAKE_ARG
    #undef OPENCL_MAKE_ARGS
    #undef OPENCL_INST_ARG
    #undef OPENCL_INSTALL_ARGS
    #undef OPENCL_SET_KERNEL
    #undef OPENCL_SET_KERNELS
#endif//ITERATING
#endif// OPENCL_DONT_USE_PREPROCESSED_FILES
