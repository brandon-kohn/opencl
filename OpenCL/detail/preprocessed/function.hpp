//
//  Copyright Brandon Kohn 2012
//
//  Distributed under the Boost Software License, Version 1.0. (See
//  accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)
//! THIS FILE IS AUTOGENERATED. CHANGES MADE TO THIS FILE WILL BE 
//! LOST WHEN IT IS REGENERATED.
//
namespace opencl
{
    template <typename Signature, int Arity, typename ResultType>
    struct function_impl;
    template <typename Signature>
    struct function_impl<Signature, 0, void>
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim) 
            , eventwaitlist(eventWaitList)
        {
            if( 0 != globalThreads )
                globalthreads.assign(globalThreads, globalThreads + workDim);
            if( 0 != localThreads ) 
                localthreads.assign(localThreads, localThreads + workDim);
            if( 0 != workDimOffsets )
                offsets.assign(workDimOffsets, workDimOffsets+workDim); 
        }
        
        typedef void result_type;
        
        void operator()() 
        { 
            cl_int status; 
            cl_event ndrEvt; 
            cl_int eventStatus = CL_QUEUED; 
            status = clEnqueueNDRangeKernel( 
                cmdQ, 
                knl, 
                workdims, 
                offsets.empty() ? 0 : &offsets[0], 
                globalthreads.empty() ? 0 : &globalthreads[0],
                localthreads.empty() ? 0 : &localthreads[0],
                eventwaitlist.size(), 
                eventwaitlist.empty() ? 0 : &eventwaitlist[0], 
                &ndrEvt); 
            assert(status == CL_SUCCESS); 
            status = clFlush(cmdQ); 
            assert(status == CL_SUCCESS); 
            eventStatus = CL_QUEUED; 
            while(eventStatus != CL_COMPLETE) 
            { 
                status = clGetEventInfo( 
                    ndrEvt, 
                    CL_EVENT_COMMAND_EXECUTION_STATUS, 
                    sizeof(cl_int), 
                    &eventStatus, 
                    0); 
                assert(status == CL_SUCCESS); 
            } 
            status = clReleaseEvent(ndrEvt); 
            assert(status == CL_SUCCESS); 
        } 
        
    private:
        kernel knl;
        cl_context ctx;
        command_queue cmdQ;
        std::size_t workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event> eventwaitlist;
    };
    template <typename Signature, typename ResultType>
    struct function_impl<Signature, 0, ResultType>
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim) 
            , eventwaitlist(eventWaitList)
        {
            if( 0 != globalThreads )
                globalthreads.assign(globalThreads, globalThreads + workDim);
            if( 0 != localThreads ) 
                localthreads.assign(localThreads, localThreads + workDim);
            if( 0 != workDimOffsets )
                offsets.assign(workDimOffsets, workDimOffsets+workDim); 
        }
        typedef ResultType result_type; 
        result_type operator()() 
        { 
            cl_int status; 
            cl_event ndrEvt; 
            cl_int eventStatus = CL_QUEUED; 
            result_type r;
            result_type* pR = &r;
            arg<result_type*> argR(0, pR, ctx, cmdQ, knl);
            status = clFlush(cmdQ); 
            assert( status == CL_SUCCESS ); 
            status = clEnqueueNDRangeKernel( 
                cmdQ, 
                knl, 
                workdims, 
                offsets.empty() ? 0 : &offsets[0], 
                globalthreads.empty() ? 0 : &globalthreads[0],
                localthreads.empty() ? 0 : &localthreads[0],
                eventwaitlist.size(), 
                eventwaitlist.empty() ? 0 : &eventwaitlist[0], 
                &ndrEvt); 
            assert(status == CL_SUCCESS); 
            status = clFlush(cmdQ); 
            assert(status == CL_SUCCESS); 
            eventStatus = CL_QUEUED; 
            while(eventStatus != CL_COMPLETE) 
            { 
                status = clGetEventInfo( 
                    ndrEvt, 
                    CL_EVENT_COMMAND_EXECUTION_STATUS, 
                    sizeof(cl_int), 
                    &eventStatus, 
                    0); 
                assert(status == CL_SUCCESS); 
            } 
            status = clReleaseEvent(ndrEvt); 
            assert(status == CL_SUCCESS); 
            argR.read_data();
            status = clFlush(cmdQ); 
            assert(status == CL_SUCCESS); 
            return r;
        } 
    private:
        kernel knl;
        cl_context ctx;
        command_queue cmdQ;
        std::size_t workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event> eventwaitlist;
    };
    
    template <typename Signature>
    struct function_impl<Signature, 1, void>
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim) 
            , eventwaitlist(eventWaitList)
        {
            if( 0 != globalThreads )
                globalthreads.assign(globalThreads, globalThreads + workDim);
            if( 0 != localThreads ) 
                localthreads.assign(localThreads, localThreads + workDim);
            if( 0 != workDimOffsets )
                offsets.assign(workDimOffsets, workDimOffsets+workDim); 
        }
        typedef void result_type;
        template<typename T0 >
        result_type operator()(T0 &a0) 
        { 
            cl_int status; 
            cl_event ndrEvt; 
            cl_int eventStatus = CL_QUEUED; 
            arg<T0> arg0(0,a0,ctx,cmdQ,knl); 
                status = clFlush(cmdQ); 
            assert( status == CL_SUCCESS ); 
            status = clEnqueueNDRangeKernel(
                cmdQ,
                knl,
                workdims,
                offsets.empty() ? 0 : &offsets[0],
                globalthreads.empty() ? 0 : &globalthreads[0],
                localthreads.empty() ? 0 : &localthreads[0],
                eventwaitlist.size(),
                eventwaitlist.empty() ? 0 : &eventwaitlist[0],
                &ndrEvt);
            assert(status == CL_SUCCESS);
            status = clFlush(cmdQ);
            assert(status == CL_SUCCESS);
            eventStatus = CL_QUEUED;
            while(eventStatus != CL_COMPLETE) 
            { 
                status = clGetEventInfo( 
                    ndrEvt, 
                    CL_EVENT_COMMAND_EXECUTION_STATUS, 
                    sizeof(cl_int), 
                    &eventStatus, 
                    0); 
                assert(status == CL_SUCCESS); 
            } 
            status = clReleaseEvent(ndrEvt); 
            assert(status == CL_SUCCESS); 
            arg0.read_data();
                status = clFlush(cmdQ); 
        }
        
    private:
        kernel knl;
        cl_context ctx;
        command_queue cmdQ;
        std::size_t workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event> eventwaitlist;
    };
    template <typename Signature, typename ResultType>
    struct function_impl<Signature, 1, ResultType>
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim) 
            , eventwaitlist(eventWaitList)
        {
            if( 0 != globalThreads )
                globalthreads.assign(globalThreads, globalThreads + workDim);
            if( 0 != localThreads ) 
                localthreads.assign(localThreads, localThreads + workDim);
            if( 0 != workDimOffsets )
                offsets.assign(workDimOffsets, workDimOffsets+workDim); 
        }
        typedef ResultType result_type;
        
        template<typename T0 >
        result_type operator()(T0 &a0) 
        { 
            cl_int status; 
            cl_event ndrEvt; 
            cl_int eventStatus = CL_QUEUED; 
            arg<T0> arg0(0,a0,ctx,cmdQ,knl); 
            typedef typename result<Signature>::type result_type;
            result_type r;
            result_type* pR = &r;
            arg<result_type*> argR(1, pR, ctx, cmdQ, knl);
            status = clFlush(cmdQ);
            assert( status == CL_SUCCESS );
            status = clEnqueueNDRangeKernel(
                cmdQ,
                knl,
                workdims,
                offsets.empty() ? 0 : &offsets[0],
                globalthreads.empty() ? 0 : &globalthreads[0],
                localthreads.empty() ? 0 : &localthreads[0],
                eventwaitlist.size(),
                eventwaitlist.empty() ? 0 : &eventwaitlist[0],
                &ndrEvt);
            assert(status == CL_SUCCESS);
            status = clFlush(cmdQ);
            assert(status == CL_SUCCESS);
            eventStatus = CL_QUEUED;
            while(eventStatus != CL_COMPLETE) 
            { 
                status = clGetEventInfo( 
                    ndrEvt, 
                    CL_EVENT_COMMAND_EXECUTION_STATUS, 
                    sizeof(cl_int), 
                    &eventStatus, 
                    0); 
                assert(status == CL_SUCCESS); 
            } 
            status = clReleaseEvent(ndrEvt); 
            assert(status == CL_SUCCESS); 
            arg0.read_data();
            argR.read_data();
            status = clFlush(cmdQ);
            return r;
        }
    private:
        kernel knl;
        cl_context ctx;
        command_queue cmdQ;
        std::size_t workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event> eventwaitlist;
    };
    template <typename Signature>
    struct function_impl<Signature, 2, void>
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim) 
            , eventwaitlist(eventWaitList)
        {
            if( 0 != globalThreads )
                globalthreads.assign(globalThreads, globalThreads + workDim);
            if( 0 != localThreads ) 
                localthreads.assign(localThreads, localThreads + workDim);
            if( 0 != workDimOffsets )
                offsets.assign(workDimOffsets, workDimOffsets+workDim); 
        }
        typedef void result_type;
        template<typename T0 , typename T1 >
        result_type operator()(T0 &a0 , T1 &a1) 
        { 
            cl_int status; 
            cl_event ndrEvt; 
            cl_int eventStatus = CL_QUEUED; 
            arg<T0> arg0(0,a0,ctx,cmdQ,knl); arg<T1> arg1(1,a1,ctx,cmdQ,knl); 
                status = clFlush(cmdQ); 
            assert( status == CL_SUCCESS ); 
            status = clEnqueueNDRangeKernel(
                cmdQ,
                knl,
                workdims,
                offsets.empty() ? 0 : &offsets[0],
                globalthreads.empty() ? 0 : &globalthreads[0],
                localthreads.empty() ? 0 : &localthreads[0],
                eventwaitlist.size(),
                eventwaitlist.empty() ? 0 : &eventwaitlist[0],
                &ndrEvt);
            assert(status == CL_SUCCESS);
            status = clFlush(cmdQ);
            assert(status == CL_SUCCESS);
            eventStatus = CL_QUEUED;
            while(eventStatus != CL_COMPLETE) 
            { 
                status = clGetEventInfo( 
                    ndrEvt, 
                    CL_EVENT_COMMAND_EXECUTION_STATUS, 
                    sizeof(cl_int), 
                    &eventStatus, 
                    0); 
                assert(status == CL_SUCCESS); 
            } 
            status = clReleaseEvent(ndrEvt); 
            assert(status == CL_SUCCESS); 
            arg0.read_data(); arg1.read_data();
                status = clFlush(cmdQ); 
        }
        
    private:
        kernel knl;
        cl_context ctx;
        command_queue cmdQ;
        std::size_t workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event> eventwaitlist;
    };
    template <typename Signature, typename ResultType>
    struct function_impl<Signature, 2, ResultType>
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim) 
            , eventwaitlist(eventWaitList)
        {
            if( 0 != globalThreads )
                globalthreads.assign(globalThreads, globalThreads + workDim);
            if( 0 != localThreads ) 
                localthreads.assign(localThreads, localThreads + workDim);
            if( 0 != workDimOffsets )
                offsets.assign(workDimOffsets, workDimOffsets+workDim); 
        }
        typedef ResultType result_type;
        
        template<typename T0 , typename T1 >
        result_type operator()(T0 &a0 , T1 &a1) 
        { 
            cl_int status; 
            cl_event ndrEvt; 
            cl_int eventStatus = CL_QUEUED; 
            arg<T0> arg0(0,a0,ctx,cmdQ,knl); arg<T1> arg1(1,a1,ctx,cmdQ,knl); 
            typedef typename result<Signature>::type result_type;
            result_type r;
            result_type* pR = &r;
            arg<result_type*> argR(2, pR, ctx, cmdQ, knl);
            status = clFlush(cmdQ);
            assert( status == CL_SUCCESS );
            status = clEnqueueNDRangeKernel(
                cmdQ,
                knl,
                workdims,
                offsets.empty() ? 0 : &offsets[0],
                globalthreads.empty() ? 0 : &globalthreads[0],
                localthreads.empty() ? 0 : &localthreads[0],
                eventwaitlist.size(),
                eventwaitlist.empty() ? 0 : &eventwaitlist[0],
                &ndrEvt);
            assert(status == CL_SUCCESS);
            status = clFlush(cmdQ);
            assert(status == CL_SUCCESS);
            eventStatus = CL_QUEUED;
            while(eventStatus != CL_COMPLETE) 
            { 
                status = clGetEventInfo( 
                    ndrEvt, 
                    CL_EVENT_COMMAND_EXECUTION_STATUS, 
                    sizeof(cl_int), 
                    &eventStatus, 
                    0); 
                assert(status == CL_SUCCESS); 
            } 
            status = clReleaseEvent(ndrEvt); 
            assert(status == CL_SUCCESS); 
            arg0.read_data(); arg1.read_data();
            argR.read_data();
            status = clFlush(cmdQ);
            return r;
        }
    private:
        kernel knl;
        cl_context ctx;
        command_queue cmdQ;
        std::size_t workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event> eventwaitlist;
    };
    template <typename Signature>
    struct function_impl<Signature, 3, void>
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim) 
            , eventwaitlist(eventWaitList)
        {
            if( 0 != globalThreads )
                globalthreads.assign(globalThreads, globalThreads + workDim);
            if( 0 != localThreads ) 
                localthreads.assign(localThreads, localThreads + workDim);
            if( 0 != workDimOffsets )
                offsets.assign(workDimOffsets, workDimOffsets+workDim); 
        }
        typedef void result_type;
        template<typename T0 , typename T1 , typename T2 >
        result_type operator()(T0 &a0 , T1 &a1 , T2 &a2) 
        { 
            cl_int status; 
            cl_event ndrEvt; 
            cl_int eventStatus = CL_QUEUED; 
            arg<T0> arg0(0,a0,ctx,cmdQ,knl); arg<T1> arg1(1,a1,ctx,cmdQ,knl); arg<T2> arg2(2,a2,ctx,cmdQ,knl); 
                status = clFlush(cmdQ); 
            assert( status == CL_SUCCESS ); 
            status = clEnqueueNDRangeKernel(
                cmdQ,
                knl,
                workdims,
                offsets.empty() ? 0 : &offsets[0],
                globalthreads.empty() ? 0 : &globalthreads[0],
                localthreads.empty() ? 0 : &localthreads[0],
                eventwaitlist.size(),
                eventwaitlist.empty() ? 0 : &eventwaitlist[0],
                &ndrEvt);
            assert(status == CL_SUCCESS);
            status = clFlush(cmdQ);
            assert(status == CL_SUCCESS);
            eventStatus = CL_QUEUED;
            while(eventStatus != CL_COMPLETE) 
            { 
                status = clGetEventInfo( 
                    ndrEvt, 
                    CL_EVENT_COMMAND_EXECUTION_STATUS, 
                    sizeof(cl_int), 
                    &eventStatus, 
                    0); 
                assert(status == CL_SUCCESS); 
            } 
            status = clReleaseEvent(ndrEvt); 
            assert(status == CL_SUCCESS); 
            arg0.read_data(); arg1.read_data(); arg2.read_data();
                status = clFlush(cmdQ); 
        }
        
    private:
        kernel knl;
        cl_context ctx;
        command_queue cmdQ;
        std::size_t workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event> eventwaitlist;
    };
    template <typename Signature, typename ResultType>
    struct function_impl<Signature, 3, ResultType>
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim) 
            , eventwaitlist(eventWaitList)
        {
            if( 0 != globalThreads )
                globalthreads.assign(globalThreads, globalThreads + workDim);
            if( 0 != localThreads ) 
                localthreads.assign(localThreads, localThreads + workDim);
            if( 0 != workDimOffsets )
                offsets.assign(workDimOffsets, workDimOffsets+workDim); 
        }
        typedef ResultType result_type;
        
        template<typename T0 , typename T1 , typename T2 >
        result_type operator()(T0 &a0 , T1 &a1 , T2 &a2) 
        { 
            cl_int status; 
            cl_event ndrEvt; 
            cl_int eventStatus = CL_QUEUED; 
            arg<T0> arg0(0,a0,ctx,cmdQ,knl); arg<T1> arg1(1,a1,ctx,cmdQ,knl); arg<T2> arg2(2,a2,ctx,cmdQ,knl); 
            typedef typename result<Signature>::type result_type;
            result_type r;
            result_type* pR = &r;
            arg<result_type*> argR(3, pR, ctx, cmdQ, knl);
            status = clFlush(cmdQ);
            assert( status == CL_SUCCESS );
            status = clEnqueueNDRangeKernel(
                cmdQ,
                knl,
                workdims,
                offsets.empty() ? 0 : &offsets[0],
                globalthreads.empty() ? 0 : &globalthreads[0],
                localthreads.empty() ? 0 : &localthreads[0],
                eventwaitlist.size(),
                eventwaitlist.empty() ? 0 : &eventwaitlist[0],
                &ndrEvt);
            assert(status == CL_SUCCESS);
            status = clFlush(cmdQ);
            assert(status == CL_SUCCESS);
            eventStatus = CL_QUEUED;
            while(eventStatus != CL_COMPLETE) 
            { 
                status = clGetEventInfo( 
                    ndrEvt, 
                    CL_EVENT_COMMAND_EXECUTION_STATUS, 
                    sizeof(cl_int), 
                    &eventStatus, 
                    0); 
                assert(status == CL_SUCCESS); 
            } 
            status = clReleaseEvent(ndrEvt); 
            assert(status == CL_SUCCESS); 
            arg0.read_data(); arg1.read_data(); arg2.read_data();
            argR.read_data();
            status = clFlush(cmdQ);
            return r;
        }
    private:
        kernel knl;
        cl_context ctx;
        command_queue cmdQ;
        std::size_t workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event> eventwaitlist;
    };
    template <typename Signature>
    struct function_impl<Signature, 4, void>
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim) 
            , eventwaitlist(eventWaitList)
        {
            if( 0 != globalThreads )
                globalthreads.assign(globalThreads, globalThreads + workDim);
            if( 0 != localThreads ) 
                localthreads.assign(localThreads, localThreads + workDim);
            if( 0 != workDimOffsets )
                offsets.assign(workDimOffsets, workDimOffsets+workDim); 
        }
        typedef void result_type;
        template<typename T0 , typename T1 , typename T2 , typename T3 >
        result_type operator()(T0 &a0 , T1 &a1 , T2 &a2 , T3 &a3) 
        { 
            cl_int status; 
            cl_event ndrEvt; 
            cl_int eventStatus = CL_QUEUED; 
            arg<T0> arg0(0,a0,ctx,cmdQ,knl); arg<T1> arg1(1,a1,ctx,cmdQ,knl); arg<T2> arg2(2,a2,ctx,cmdQ,knl); arg<T3> arg3(3,a3,ctx,cmdQ,knl); 
                status = clFlush(cmdQ); 
            assert( status == CL_SUCCESS ); 
            status = clEnqueueNDRangeKernel(
                cmdQ,
                knl,
                workdims,
                offsets.empty() ? 0 : &offsets[0],
                globalthreads.empty() ? 0 : &globalthreads[0],
                localthreads.empty() ? 0 : &localthreads[0],
                eventwaitlist.size(),
                eventwaitlist.empty() ? 0 : &eventwaitlist[0],
                &ndrEvt);
            assert(status == CL_SUCCESS);
            status = clFlush(cmdQ);
            assert(status == CL_SUCCESS);
            eventStatus = CL_QUEUED;
            while(eventStatus != CL_COMPLETE) 
            { 
                status = clGetEventInfo( 
                    ndrEvt, 
                    CL_EVENT_COMMAND_EXECUTION_STATUS, 
                    sizeof(cl_int), 
                    &eventStatus, 
                    0); 
                assert(status == CL_SUCCESS); 
            } 
            status = clReleaseEvent(ndrEvt); 
            assert(status == CL_SUCCESS); 
            arg0.read_data(); arg1.read_data(); arg2.read_data(); arg3.read_data();
                status = clFlush(cmdQ); 
        }
        
    private:
        kernel knl;
        cl_context ctx;
        command_queue cmdQ;
        std::size_t workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event> eventwaitlist;
    };
    template <typename Signature, typename ResultType>
    struct function_impl<Signature, 4, ResultType>
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim) 
            , eventwaitlist(eventWaitList)
        {
            if( 0 != globalThreads )
                globalthreads.assign(globalThreads, globalThreads + workDim);
            if( 0 != localThreads ) 
                localthreads.assign(localThreads, localThreads + workDim);
            if( 0 != workDimOffsets )
                offsets.assign(workDimOffsets, workDimOffsets+workDim); 
        }
        typedef ResultType result_type;
        
        template<typename T0 , typename T1 , typename T2 , typename T3 >
        result_type operator()(T0 &a0 , T1 &a1 , T2 &a2 , T3 &a3) 
        { 
            cl_int status; 
            cl_event ndrEvt; 
            cl_int eventStatus = CL_QUEUED; 
            arg<T0> arg0(0,a0,ctx,cmdQ,knl); arg<T1> arg1(1,a1,ctx,cmdQ,knl); arg<T2> arg2(2,a2,ctx,cmdQ,knl); arg<T3> arg3(3,a3,ctx,cmdQ,knl); 
            typedef typename result<Signature>::type result_type;
            result_type r;
            result_type* pR = &r;
            arg<result_type*> argR(4, pR, ctx, cmdQ, knl);
            status = clFlush(cmdQ);
            assert( status == CL_SUCCESS );
            status = clEnqueueNDRangeKernel(
                cmdQ,
                knl,
                workdims,
                offsets.empty() ? 0 : &offsets[0],
                globalthreads.empty() ? 0 : &globalthreads[0],
                localthreads.empty() ? 0 : &localthreads[0],
                eventwaitlist.size(),
                eventwaitlist.empty() ? 0 : &eventwaitlist[0],
                &ndrEvt);
            assert(status == CL_SUCCESS);
            status = clFlush(cmdQ);
            assert(status == CL_SUCCESS);
            eventStatus = CL_QUEUED;
            while(eventStatus != CL_COMPLETE) 
            { 
                status = clGetEventInfo( 
                    ndrEvt, 
                    CL_EVENT_COMMAND_EXECUTION_STATUS, 
                    sizeof(cl_int), 
                    &eventStatus, 
                    0); 
                assert(status == CL_SUCCESS); 
            } 
            status = clReleaseEvent(ndrEvt); 
            assert(status == CL_SUCCESS); 
            arg0.read_data(); arg1.read_data(); arg2.read_data(); arg3.read_data();
            argR.read_data();
            status = clFlush(cmdQ);
            return r;
        }
    private:
        kernel knl;
        cl_context ctx;
        command_queue cmdQ;
        std::size_t workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event> eventwaitlist;
    };
    template <typename Signature>
    struct function_impl<Signature, 5, void>
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim) 
            , eventwaitlist(eventWaitList)
        {
            if( 0 != globalThreads )
                globalthreads.assign(globalThreads, globalThreads + workDim);
            if( 0 != localThreads ) 
                localthreads.assign(localThreads, localThreads + workDim);
            if( 0 != workDimOffsets )
                offsets.assign(workDimOffsets, workDimOffsets+workDim); 
        }
        typedef void result_type;
        template<typename T0 , typename T1 , typename T2 , typename T3 , typename T4 >
        result_type operator()(T0 &a0 , T1 &a1 , T2 &a2 , T3 &a3 , T4 &a4) 
        { 
            cl_int status; 
            cl_event ndrEvt; 
            cl_int eventStatus = CL_QUEUED; 
            arg<T0> arg0(0,a0,ctx,cmdQ,knl); arg<T1> arg1(1,a1,ctx,cmdQ,knl); arg<T2> arg2(2,a2,ctx,cmdQ,knl); arg<T3> arg3(3,a3,ctx,cmdQ,knl); arg<T4> arg4(4,a4,ctx,cmdQ,knl); 
                status = clFlush(cmdQ); 
            assert( status == CL_SUCCESS ); 
            status = clEnqueueNDRangeKernel(
                cmdQ,
                knl,
                workdims,
                offsets.empty() ? 0 : &offsets[0],
                globalthreads.empty() ? 0 : &globalthreads[0],
                localthreads.empty() ? 0 : &localthreads[0],
                eventwaitlist.size(),
                eventwaitlist.empty() ? 0 : &eventwaitlist[0],
                &ndrEvt);
            assert(status == CL_SUCCESS);
            status = clFlush(cmdQ);
            assert(status == CL_SUCCESS);
            eventStatus = CL_QUEUED;
            while(eventStatus != CL_COMPLETE) 
            { 
                status = clGetEventInfo( 
                    ndrEvt, 
                    CL_EVENT_COMMAND_EXECUTION_STATUS, 
                    sizeof(cl_int), 
                    &eventStatus, 
                    0); 
                assert(status == CL_SUCCESS); 
            } 
            status = clReleaseEvent(ndrEvt); 
            assert(status == CL_SUCCESS); 
            arg0.read_data(); arg1.read_data(); arg2.read_data(); arg3.read_data(); arg4.read_data();
                status = clFlush(cmdQ); 
        }
        
    private:
        kernel knl;
        cl_context ctx;
        command_queue cmdQ;
        std::size_t workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event> eventwaitlist;
    };
    template <typename Signature, typename ResultType>
    struct function_impl<Signature, 5, ResultType>
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim) 
            , eventwaitlist(eventWaitList)
        {
            if( 0 != globalThreads )
                globalthreads.assign(globalThreads, globalThreads + workDim);
            if( 0 != localThreads ) 
                localthreads.assign(localThreads, localThreads + workDim);
            if( 0 != workDimOffsets )
                offsets.assign(workDimOffsets, workDimOffsets+workDim); 
        }
        typedef ResultType result_type;
        
        template<typename T0 , typename T1 , typename T2 , typename T3 , typename T4 >
        result_type operator()(T0 &a0 , T1 &a1 , T2 &a2 , T3 &a3 , T4 &a4) 
        { 
            cl_int status; 
            cl_event ndrEvt; 
            cl_int eventStatus = CL_QUEUED; 
            arg<T0> arg0(0,a0,ctx,cmdQ,knl); arg<T1> arg1(1,a1,ctx,cmdQ,knl); arg<T2> arg2(2,a2,ctx,cmdQ,knl); arg<T3> arg3(3,a3,ctx,cmdQ,knl); arg<T4> arg4(4,a4,ctx,cmdQ,knl); 
            typedef typename result<Signature>::type result_type;
            result_type r;
            result_type* pR = &r;
            arg<result_type*> argR(5, pR, ctx, cmdQ, knl);
            status = clFlush(cmdQ);
            assert( status == CL_SUCCESS );
            status = clEnqueueNDRangeKernel(
                cmdQ,
                knl,
                workdims,
                offsets.empty() ? 0 : &offsets[0],
                globalthreads.empty() ? 0 : &globalthreads[0],
                localthreads.empty() ? 0 : &localthreads[0],
                eventwaitlist.size(),
                eventwaitlist.empty() ? 0 : &eventwaitlist[0],
                &ndrEvt);
            assert(status == CL_SUCCESS);
            status = clFlush(cmdQ);
            assert(status == CL_SUCCESS);
            eventStatus = CL_QUEUED;
            while(eventStatus != CL_COMPLETE) 
            { 
                status = clGetEventInfo( 
                    ndrEvt, 
                    CL_EVENT_COMMAND_EXECUTION_STATUS, 
                    sizeof(cl_int), 
                    &eventStatus, 
                    0); 
                assert(status == CL_SUCCESS); 
            } 
            status = clReleaseEvent(ndrEvt); 
            assert(status == CL_SUCCESS); 
            arg0.read_data(); arg1.read_data(); arg2.read_data(); arg3.read_data(); arg4.read_data();
            argR.read_data();
            status = clFlush(cmdQ);
            return r;
        }
    private:
        kernel knl;
        cl_context ctx;
        command_queue cmdQ;
        std::size_t workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event> eventwaitlist;
    };
    template <typename Signature>
    struct function_impl<Signature, 6, void>
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim) 
            , eventwaitlist(eventWaitList)
        {
            if( 0 != globalThreads )
                globalthreads.assign(globalThreads, globalThreads + workDim);
            if( 0 != localThreads ) 
                localthreads.assign(localThreads, localThreads + workDim);
            if( 0 != workDimOffsets )
                offsets.assign(workDimOffsets, workDimOffsets+workDim); 
        }
        typedef void result_type;
        template<typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 >
        result_type operator()(T0 &a0 , T1 &a1 , T2 &a2 , T3 &a3 , T4 &a4 , T5 &a5) 
        { 
            cl_int status; 
            cl_event ndrEvt; 
            cl_int eventStatus = CL_QUEUED; 
            arg<T0> arg0(0,a0,ctx,cmdQ,knl); arg<T1> arg1(1,a1,ctx,cmdQ,knl); arg<T2> arg2(2,a2,ctx,cmdQ,knl); arg<T3> arg3(3,a3,ctx,cmdQ,knl); arg<T4> arg4(4,a4,ctx,cmdQ,knl); arg<T5> arg5(5,a5,ctx,cmdQ,knl); 
                status = clFlush(cmdQ); 
            assert( status == CL_SUCCESS ); 
            status = clEnqueueNDRangeKernel(
                cmdQ,
                knl,
                workdims,
                offsets.empty() ? 0 : &offsets[0],
                globalthreads.empty() ? 0 : &globalthreads[0],
                localthreads.empty() ? 0 : &localthreads[0],
                eventwaitlist.size(),
                eventwaitlist.empty() ? 0 : &eventwaitlist[0],
                &ndrEvt);
            assert(status == CL_SUCCESS);
            status = clFlush(cmdQ);
            assert(status == CL_SUCCESS);
            eventStatus = CL_QUEUED;
            while(eventStatus != CL_COMPLETE) 
            { 
                status = clGetEventInfo( 
                    ndrEvt, 
                    CL_EVENT_COMMAND_EXECUTION_STATUS, 
                    sizeof(cl_int), 
                    &eventStatus, 
                    0); 
                assert(status == CL_SUCCESS); 
            } 
            status = clReleaseEvent(ndrEvt); 
            assert(status == CL_SUCCESS); 
            arg0.read_data(); arg1.read_data(); arg2.read_data(); arg3.read_data(); arg4.read_data(); arg5.read_data();
                status = clFlush(cmdQ); 
        }
        
    private:
        kernel knl;
        cl_context ctx;
        command_queue cmdQ;
        std::size_t workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event> eventwaitlist;
    };
    template <typename Signature, typename ResultType>
    struct function_impl<Signature, 6, ResultType>
    {
        function_impl( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
            , const std::size_t* globalThreads, const std::size_t* localThreads
            , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
            : knl(knl)
            , ctx(ctx)
            , cmdQ(q)
            , workdims(workDim) 
            , eventwaitlist(eventWaitList)
        {
            if( 0 != globalThreads )
                globalthreads.assign(globalThreads, globalThreads + workDim);
            if( 0 != localThreads ) 
                localthreads.assign(localThreads, localThreads + workDim);
            if( 0 != workDimOffsets )
                offsets.assign(workDimOffsets, workDimOffsets+workDim); 
        }
        typedef ResultType result_type;
        
        template<typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 >
        result_type operator()(T0 &a0 , T1 &a1 , T2 &a2 , T3 &a3 , T4 &a4 , T5 &a5) 
        { 
            cl_int status; 
            cl_event ndrEvt; 
            cl_int eventStatus = CL_QUEUED; 
            arg<T0> arg0(0,a0,ctx,cmdQ,knl); arg<T1> arg1(1,a1,ctx,cmdQ,knl); arg<T2> arg2(2,a2,ctx,cmdQ,knl); arg<T3> arg3(3,a3,ctx,cmdQ,knl); arg<T4> arg4(4,a4,ctx,cmdQ,knl); arg<T5> arg5(5,a5,ctx,cmdQ,knl); 
            typedef typename result<Signature>::type result_type;
            result_type r;
            result_type* pR = &r;
            arg<result_type*> argR(6, pR, ctx, cmdQ, knl);
            status = clFlush(cmdQ);
            assert( status == CL_SUCCESS );
            status = clEnqueueNDRangeKernel(
                cmdQ,
                knl,
                workdims,
                offsets.empty() ? 0 : &offsets[0],
                globalthreads.empty() ? 0 : &globalthreads[0],
                localthreads.empty() ? 0 : &localthreads[0],
                eventwaitlist.size(),
                eventwaitlist.empty() ? 0 : &eventwaitlist[0],
                &ndrEvt);
            assert(status == CL_SUCCESS);
            status = clFlush(cmdQ);
            assert(status == CL_SUCCESS);
            eventStatus = CL_QUEUED;
            while(eventStatus != CL_COMPLETE) 
            { 
                status = clGetEventInfo( 
                    ndrEvt, 
                    CL_EVENT_COMMAND_EXECUTION_STATUS, 
                    sizeof(cl_int), 
                    &eventStatus, 
                    0); 
                assert(status == CL_SUCCESS); 
            } 
            status = clReleaseEvent(ndrEvt); 
            assert(status == CL_SUCCESS); 
            arg0.read_data(); arg1.read_data(); arg2.read_data(); arg3.read_data(); arg4.read_data(); arg5.read_data();
            argR.read_data();
            status = clFlush(cmdQ);
            return r;
        }
    private:
        kernel knl;
        cl_context ctx;
        command_queue cmdQ;
        std::size_t workdims;
        std::vector<std::size_t> globalthreads;
        std::vector<std::size_t> localthreads;
        std::vector<std::size_t> offsets;
        std::vector<cl_event> eventwaitlist;
    };
	template <typename Signature>
	class function : function_impl<Signature, boost::function_types::function_arity<Signature>::value, typename boost::function_traits<Signature>::result_type>
	{
        typedef function_impl<Signature, boost::function_types::function_arity<Signature>::value, typename boost::function_traits<Signature>::result_type> base_type;
	public:
		function( const kernel& knl, const cl_context& ctx, const command_queue& q, cl_uint workDim
                , const std::size_t* globalThreads, const std::size_t* localThreads
                , const std::vector<cl_event>& eventWaitList = std::vector<cl_event>(), const std::size_t* workDimOffsets = 0)	
			: base_type(knl, ctx, q, workDim, globalThreads, localThreads, eventWaitList, workDimOffsets)
		{}
	
        using base_type::operator();
   };
}//namespace opencl;
